---
title: "Fernerkundung globale Ökologie: 4. Landnutzungsänderung"
author: "[Lasslop](mailto:gitta.lasslop@senckenberg.de)/[Werner](mailto:christian.werner@senckenberg.de)"
classoption: a4paper
#lang: de-DE
bibliography: literatur.bib
output:
  tufte::tufte_handout:
##    latex_engine: xelatex
    fig_caption: yes
    includes:
      in_header: styles.tex
##    toc: true
    highlight: default
---

# Landnutzungswandel/Land-Use Change (LUC)

Über den jährlich ermittelten Landnutzungstypen (Land cover type, LCT) lässt sich die Veränderung der Landnutzung über den Zeitraum der vorhandenen Satellitenmessungen ermitteln.

## Daten
Das MODIS Kürzel für die heutige Sitzung ist [MCD12Q1](https://lpdaac.usgs.gov/dataset_discovery/modis/modis_products_table/mcd12q1).

## Literatur
Generelle Literatur zu den relevanten MODIS Produkten:  
@Mertes2015Detectingchangeurban @Yin2014MappingAnnualLand @Broich2011Remotelysensedforest @Friedl2010MODISCollectionglobal @Schneider2009newmapglobal

Für eine Diskussion von Unsicherheiten der genutzten Produkte:  
@Fritz2011Highlightingcontinueduncertainty @Park2014CharacteristicsMODISlandcover

## Initialisieren
Laden der benötigten Pakete, sowie initialisieren der Umgebungsvariablen.
```{r, message=FALSE, warning=FALSE}
library(raster)
library(ggplot2)
library(reshape2)

library(FEglobaleOekologie)
##fegloekOptions(baseDir = "/home/gitta/R/Lehre") 
fegloekOptions(baseDir =
               "/Users/cwerner/Dropbox/Documents/2018/teaching/fe_oekologie_2018/handouts")
fegloekOptions(region="NWBRAZIL")
fegloekInit()
```
Die benötigten Fernerkundungsdaten finden Sie online: https://powerfolder.gwdg.de/filestable/MjRGYXU2YUViNThFdU5yMlFhZXV2
Laden Sie dort die Datei "LUC_{REGION}.zip" und verschieben Sie die entzippten Dateien in den folgenden Ordner:
```{r, message=FALSE, warning=FALSE, eval=FALSE}
file.path(getOption("fegloekDataDir"), getOption("fegloekRegion"))
```

Ausserdem benötigen wir die Funktion *geotiff2df()* aus den letzten Sitzungen. Kopieren Sie den Quelltext der Funktion in dieses Script oder laden Sie die Funktion aus einer externen Datei *functions.R* (in ihrem OLAT_Skript haben wir die Funktion der letzten Sitzung schon eingefügt - generell ist es aber ratsam bei größeren Projekten häufig verwendete Funktionen in externe Dateien auszulagern und mit source in the Laufzeitumgebung zu laden).

```{r, messsage=FALSE}
source(file.path(getOption("fegloekBaseDir"), "R", "functions.R"), encoding=getOption("encoding"))
```

### Aufgabe

Erweitern Sie die Funktion *geotiff2df()* so, dass Sie mit der Übergabe eines optionalen Arguments "crop_extent" die Ausgabe beschneiden können. Hierzu  benötigen Sie:  
(1) ein zusaetzliches Funktionsargument ('crop_extent') mit dem Standardwert NA (für 'nicht definiert') und  
(2) den Befehl crop (?crop) um die Ausdehnung unserer Karte auf die Grenzen 'crop_extent' zu beschneiden.   
In unserem heutigen Skript haben wir die Position für die Funktionserweiterung mit einem Kommentar markiert. **Hinweis:** Für den Aufbau der if-Bedingung können Sie sich bei der folgenden Abfrage von 'valid_range' in der Funktion inspirieren lassen.
}

## Verarbeiten der Daten

In unseren MODIS Beispiel-Daten sind LUC Informationen für die Jahre 2001 -- 2010 vorhanden. Die Jahre werden in einer for-Schleife zwischen start_year und end_year durchlaufen und mit jedem Durchlauf wird berechnet, wieviel Pixel als bewaldet und unbewaldet klassifiziert sind. Im ersten Jahr (year == start_year) wird der data.frame tsForest erzeugt und in den folgenden Jahren wird diesem data.frame je eine Zeile hinzugefügt (rbind, "row bind"). Für das erste und letze Jahr wird eine Karte erzeugt (Hinweis: die Daten der Region BORNEO für das Jahr 2001 enthalten ungewöhnlich viele nicht-klassifizierte Pixel - starten hier deshalb mit dem Jahr 2002; generell sollten Sie bei LUC Analysen immer prüfen ob Unregelmässigkeiten in einer Zeitscheibe zu beobachten sind - sie könnten sich auch die Quality Control Daten des Produkts ansehen; diese finden Sie auf der MODIS-Homepage als seperaten Datensatz).

```{r}
start_year <- 2001
end_year <- 2010
```


```{r, echo=FALSE, results="hide", message=FALSE, warning=FALSE, fig.width=5, fig.height=4, fig.margin=TRUE}
forestExtent <- getOption("fegloekLUCExtent")
data.dir <- file.path(getOption("fegloekDataDir"), getOption("fegloekRegion"))
for (year in start_year:end_year) {
  file <- paste0("MCD12Q1_", year ,"-01-01.Land_Cover_Type_3.tif")
  dfLCT <- geotiff2df(file.path(data.dir, file), name="id", crop=forestExtent, valid_range = c(0, 253))

  # reproject border lines, if not yet done
  if (!exists("regionmap")) {
    rLCT <- raster(file.path(data.dir, file))
    rLCT = crop(rLCT, forestExtent)
    regionmap = borderSubset(rLCT)
  }

  dfLCT$name=""
  dfLCT$name[dfLCT$id < 5 | dfLCT$id > 8] = "unforested"
  dfLCT$name[dfLCT$id > 4 & dfLCT$id < 9] = "forested"
  dfLCT$name[dfLCT$id == 0] = "water"

  nFor = length(dfLCT$name[dfLCT$name == "forested"])
  nUnf = length(dfLCT$name[dfLCT$name == "unforested"])

  if (year == start_year) {
    tsForest = data.frame(Year=year, forested=nFor, unforested=nUnf)
  } else {
    tsForest = rbind(tsForest, data.frame(Year=year, forested=nFor, unforested=nUnf))
  }

  if (year == start_year || year == end_year) {
    p <- ggplot(dfLCT, aes(x=x, y=y))
    p <- p + geom_raster(aes(fill=name))
    p <- p + geom_path(data=regionmap, size=0.1, colour="black", aes(x=long, y=lat, group=group))
    p <- p + coord_fixed(xlim=c(min(dfLCT$x), max(dfLCT$x)),
                         ylim=c(min(dfLCT$y), max(dfLCT$y)))
    p <- p + theme(legend.position = "bottom")
    p <- p + scale_fill_manual(values=c("unforested"="brown", "forested"="darkgreen",
                                        "water"="lightblue"), drop=FALSE)
    p <- p + guides(fill = guide_legend(title=NULL, ncol = 4))
    label = paste0(nFor, " * km^2")
    p <- p + annotate("text", label=label, x=3e5, y=9.05e6,
                      color="white", parse=TRUE, size=6)
    label = paste0(nUnf, " * km^2")
    p <- p + annotate("text", label=label, x=3e5, y=8.95e6,
                      color="white", parse=TRUE, size=6)
    p <- p + labs(title=year)
    p <- p + xlab("easting")
    p <- p + ylab("northing")
    file <- paste0(getOption("fegloekRegion"), "_LUC_", year, ".pdf")
    print(p)
  }
}
```

Der *crop* Befehl schneidet eine von uns vordefinierte Region (mittels einer Hilfsfunktion des Pakets FEglobaleOekologie (getOption("fegloekLUCExtent")) aus den Daten aus. Diese Region muss als zusätzliches/ optionales Funktionsargument der Funktion 'geotiff2df()' übergeben werden. Die Begrenzungsdaten liegen in der UTM-Projektion vor. Um Ländergrenzen dazustellen zu können müssen wir zunächst die vorhandene Karte auf die jeweilige Projektion der Region umprojiziert. Das wird in der von uns geschriebenen Funktion 'borderSubset()' gemacht.

Anschliessend wird für jedes Jahr eine neue Spalte erzeugt, die Wald und nicht bewaldete Gebiete unterscheidet. Die Klassifikation in Wald / Nicht-Wald erfolgt mittels der zuletzt definierten Variable in LCT3lookuptable. Anschließend wird die Anzahl der bewaldeten und unbewaldeten Pixel pro Jahr gezählt und in dem data.frame tsForest gespeichert.


\marginnote{
\textbf{Aufgabe}\\
Aktivieren Sie innerhalb der Schleife die Zeilen mit 'annotate' und wählen sie die X- und Y-Koordinaten so, das die Informationen innerhalb der Karte erscheinen (Hinweis: der Befehl 'extent(rLCT)' gibt Ihnen die Limits der Karte aus).
}

```{r, eval=FALSE}
forestExtent <- getOption("fegloekLUCExtent")
data.dir <- file.path(getOption("fegloekDataDir"), getOption("fegloekRegion"))
for (year in start_year:end_year) {
  file <- paste0("MCD12Q1_", year ,"-01-01.Land_Cover_Type_3.tif")
  dfLCT <- geotiff2df(file.path(data.dir, file), name="id", crop=forestExtent, valid_range = c(0, 253))
  
  # reproject border lines, if not yet done
  if (!exists("regionmap")) {
    rLCT <- raster(file.path(data.dir, file))
    rLCT = crop(rLCT, forestExtent)
    regionmap = borderSubset(rLCT)
  }

  dfLCT$name = ""
  dfLCT$name[dfLCT$id < 5 | dfLCT$id > 8] = "unforested"
  dfLCT$name[dfLCT$id > 4 & dfLCT$id < 9] = "forested"
  dfLCT$name[dfLCT$id == 0] = "water"

  nFor = length(dfLCT$name[dfLCT$name == "forested"])
  nUnf = length(dfLCT$name[dfLCT$name == "unforested"])

  if (year == start_year) {
    tsForest = data.frame(Year=year, forested=nFor, unforested=nUnf)
  } else {
    tsForest = rbind(tsForest, data.frame(Year=year, forested=nFor, unforested=nUnf))
  }

  if (year == start_year || year == end_year) {
    p <- ggplot(dfLCT, aes(x=x, y=y))
    p <- p + geom_raster(aes(fill=name))
    p <- p + geom_path(data=regionmap, size=0.1, colour="black", aes(x=long, y=lat, group=group))
    p <- p + coord_fixed(xlim=c(min(dfLCT$x), max(dfLCT$x)),
                         ylim=c(min(dfLCT$y), max(dfLCT$y)))
    p <- p + theme(legend.position = "bottom")
    p <- p + scale_fill_manual(values=c("unforested"="brown", "forested"="darkgreen",
                                        "water"="lightblue"), drop=FALSE)
    p <- p + guides(fill = guide_legend(title=NULL, ncol = 4))
    
    ## label = paste0(nFor, " * km^2")
    ## p <- p + annotate("text", label=label, x=3e5, y=9.05e6,
    ##                  color="white", parse=TRUE, size=12)
    ## label = paste0(nUnf, " * km^2")
    ## p <- p + annotate("text", label=label, x=3e5, y=8.95e6,
    ##                  color="white", parse=TRUE, size=12)
    
    p <- p + labs(title=year)
    p <- p + xlab("easting")
    p <- p + ylab("northing")
    file <- paste0(getOption("fegloekRegion"), "_LUC_", year, ".pdf")
    pdf(file.path(getOption("fegloekFigDir"), file), paper="special", width=10, height=6)
    print(p)
    dev.off()
  }
}
```

Nun plotten wir die Zeitreihe. Dafür werden die Spalten 'forested' und 'unforested' mit dem Befehl 'melt' in einer Spalte namens 'value' kombiniert und eine zusätzliche Spalte names 'variable' erzeugt, die die entsprechenden alten Spaltennamen 'forested'/'unforested' enthält. Falls sich die Größen der zwei Landnurzungklassen in ihrer Region sehr stark unterscheiden können Sie mit dem Befehl 'facet_wrap' die Balken der Klassen in interschiedlichen Panelen plotten und so Trends leichter sichtbar machen. Denken Sie daran, die Variablen entsprechend ihrer obigen Definition umzubenennen.

```{r}
tsForest = melt(tsForest, measure.vars=c("forested", "unforested"))
p <- ggplot(tsForest, aes(x=Year, y=value, fill=variable))
p <- p + geom_bar(stat="identity", position="dodge")
p <- p + scale_fill_manual(values=c("unforested"="brown", "forested"="darkgreen",
                                        "water"="lightblue"), drop=FALSE)

## p <- p + facet_wrap(~variable, ncol=1, scales="free_y")
```
```{r, eval=FALSE}
file <- paste0(getOption("fegloekRegion"), "_LUC_TS.pdf")
pdf(file.path(getOption("fegloekFigDir"), file), paper="special", width=10, height=6)
print(p)
dev.off()
```

```{r, fig.width=8, fig,height=5, echo=FALSE}
print(p)
```

Die Karte mit der räumlichen Verteilung kann auch für jedes Jahr geplottet werden. Diese Bilder können Sie zu einer Animation zusammenfügen. Hierzu benötigen Sie die Erweiterung 'gganimate' der Bibliothek 'ggplot2'. Diese muss zunächst mit den folgenden Befehlen nachinstalliert werden:

```{r, eval=FALSE}
## Installation des Zusatzpakets
library(devtools)
devtools::install_github("dgrtwo/gganimate")

## laden des neuen Pakets
library(gganimate)
```

Nun modifizieren wir das Plotskript so, dass für jedes Jahr eine neuer Layer der Animation ausgegeben wird (sehen Sie sich hierzu auch die Beispiele auf [GitHub](https://github.com/dgrtwo/gganimate) an). Damit dies funtioniert müssen wir zunächst einen data.frame aller Daten (über alle Jahre) erzeugen. Hierbei wird im Gegensatz zu unserem bisherigen Skript noch dfLCT noch eine Spalte 'year' angefügt. Wir speichern die dfLCT data.frames der einzelnen Jahre dann in einer Liste (list_of_dfLCTs) um sie anschliessend mit der Befehlskombination *do.call*, *rbind* zu einem grossen data.frame zu vereinen. Diesen benutzen wir schliesslich um eine Animation mit ggplot zu erzeugen.

```{r, eval=FALSE}

forestExtent <- getOption("fegloekLUCExtent")
data.dir <- file.path(getOption("fegloekDataDir"), getOption("fegloekRegion"))

list_of_dfLCTs = list()
cnt = 1

for (year in start_year:end_year) {
  file <- paste0("MCD12Q1_", year ,"-01-01.Land_Cover_Type_3.tif")
  dfLCT <- geotiff2df(file.path(data.dir, file), name="id", crop=forestExtent, valid_range = c(0, 253))

  # reproject border lines, if not yet done
  if (!exists("regionmap")) {
    rLCT <- raster(file.path(data.dir, file))
    rLCT = crop(rLCT, forestExtent)
    regionmap = borderSubset(rLCT)
  }

  dfLCT$name=""
  dfLCT$name[dfLCT$id < 5 | dfLCT$id > 8] = "unforested"
  dfLCT$name[dfLCT$id > 4 & dfLCT$id < 9] = "forested"
  dfLCT$name[dfLCT$id == 0] = "water"

  dfLCT$year=year
  print(head(dfLCT))
  
  list_of_dfLCTs[[cnt]] = dfLCT
  cnt = cnt + 1
}

## Verknuepfung der einzelnen dfLCT data.frames zu einem grossen data.frame
dfLCT_total <- do.call("rbind", list_of_dfLCTs)


p <- ggplot(dfLCT_total, aes(x=x, y=y, frame=year))
p <- p + geom_raster(aes(fill=name))
p <- p + geom_path(data=regionmap, size=0.1, colour="black", aes(x=long, y=lat, group=group))
p <- p + coord_fixed(xlim=c(min(dfLCT$x), max(dfLCT$x)),
                         ylim=c(min(dfLCT$y), max(dfLCT$y)))
p <- p + theme(legend.position = "bottom")
p <- p + scale_fill_manual(values=c("unforested"="brown", "forested"="darkgreen",
                                        "water"="lightblue"), drop=FALSE)
p <- p + guides(fill = guide_legend(title=NULL, ncol = 4))
    
## label = paste0(nFor, " * km^2")
## p <- p + annotate("text", label=label, x=3e5, y=9.05e6,
##                  color="white", parse=TRUE, size=12)
## label = paste0(nUnf, " * km^2")
## p <- p + annotate("text", label=label, x=3e5, y=8.95e6,
##                  color="white", parse=TRUE, size=12)
    
p <- p + xlab("easting")
p <- p + ylab("northing")

gganimate(p)

```




# Hausaufgaben

1. Beschriften Sie die Achsen korrekt (Hinweis: ?xlab, ?ylab). **(0.5 Punkte)**

2. In dem Skript wird das Verhältnis Wald zu nicht-Wald in einem kleinem Ausschnitt betrachtet. Überlegen Sie sich eine eigene Klassifizierung (Urbanisierung, Landwirtschaft, Verbuschung, ...) für Ihre Region und passen Sie die Variablennamen und die Klassifizierung entsprechend an. Eventuell muss auch der zu benutzende Ausschnitt verändert werden (forestExtent; schauen Sie sich den bisherigen Wert an um die Angabe zu verstehen), damit zum Beispiel eine Stadt enthalten ist. **(2 Punkte)**

3. Beschriften Sie die x-Achse des Zeitreihen-Plots mit ganzen Zahlen damit es eher einer Zeitachse mit Jahren entspricht (?scale_x_continuous). **(0.5 Punkte)**

4. Wählen Sie eine für die Plots eine sinnvolle Farbgebung aus. Hilfe gibt es wie immer auf [docs.ggplot2.org](http://docs.ggplot2.org/current/) **(1 Punkt)**

5. Modifizieren Sie den Plot indem sie die Balkendarstellung durch Linien ersetzen. **(1 Punkt)**

6. Die Ausführen ihres Skriptes bricht ab und in der Konsole von Rstudio entdecken Sie die Fehlermeldung file does not exist". Beschreiben Sie kurz Ihr Vorgehen um den Fehler zu beheben/ einzugrenzen. **(0.5 Punkte)**

7. Mit welcher Funktion können Sie in R Spalten an einen data.frame anhängen? **(1 Punkt)**

8. Nennen Sie mindestens eine Funktion mit der man in R die Anzahl der Zeilen in einem data.frame herausfinden kann. **(0.5 Punkte)**


# Literatur
