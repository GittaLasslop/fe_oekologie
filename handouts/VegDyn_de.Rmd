---
title: "Fernerkundung globale Ökologie: 5. Vegetationsdynamik"
author: "[Lasslop](mailto:gitta.lasslop@senckenberg.de)/[Werner](mailto:christian.werner@senckenberg.de)"
bibliography: literatur.bib
classoption: a4paper
lang: de-DE
output:
  tufte::tufte_handout:
##    latex_engine: xelatex
    fig_caption: yes
    includes:
      in_header: styles.tex
##    toc: true
    highlight: default
---

# Vegetationsdynamik

Im Rahmen dieser Übung verstehen wir unter Vegetationsdynamik den Verlauf bzw. die Dauer der Vegetationsperiode. Unser heutiges MODIS Produkt ist [MCD12Q2](https://lpdaac.usgs.gov/dataset_discovery/modis/modis_products_table/mcd12q2). Weiterhin werden wir heute eine grundlegende Technik der Geodaten-Analyse behandeln: die Kombination unterschiedlicher Datenquellen zur Analyse einer Fragestellung.

## Literatur

Die relevante Literatur für heute ist: @Buitenwerf2015Threedecadesmultidimensional; @Ganguly2010Landsurfacephenology; @Soudani2008Evaluationonsetgreenup; @Zhang2006Globalvegetationphenology; @Zhang2003Monitoringvegetationphenology 

## Initialisieren

Laden der benötigten Pakete, sowie initialisieren der Umgebungsvariablen.

```{r, message=FALSE, warning=FALSE}
library(raster)
library(ggplot2)
library(reshape2)
library(FEglobaleOekologie)
fegloekOptions(baseDir =
               "/Users/cwerner/Dropbox/Documents/2018/teaching/fe_oekologie_2018/handouts")
fegloekOptions(region="NEUROPE")
fegloekInit()
```

Die benötigten Fernerkundungsdaten finden Sie online: https://powerfolder.gwdg.de/filestable/MjRGYXU2YUViNThFdU5yMlFhZXV2
Laden Sie dort die Datei "VegDyn_{REGION}.zip" und verschieben Sie die entzippten Dateien in den folgenden Ordner:

```{r, message=FALSE, warning=FALSE, eval=FALSE}
file.path(getOption("fegloekDataDir"), getOption("fegloekRegion"))
```

Bitte beachten Sie, dass Sie heute mindestens zwei Regionen herunterladen müssen. Wiederholen Sie dazu den obigen Schritt. Ausserdem benötigen wir wieder den data.frame LCT3lookuptable. Diesen finden Sie in der Datei variables.R. Es ist empehlenswert, dass Sie das Skript kopieren um die zwei Regionen getrennt bearbeiten zu können und nicht durcheinander kommen.

Um eine externe Datei (variables.R) in unser heutiges Skript zu importieren benutzen wir den Befehl 'source()'. Beachten Sie, dass sich die Datei variables.R im Unterverzeichnis R erwartet wird. Ein möglicher Pfad wäre also:

```{r echo=FALSE, out.width="100%", fig.align="center", fig.cap="Verzeichnisstruktur"}
knitr::include_graphics("RStudio_folders.png")
```

```{r, message=FALSE, warning=FALSE, eval=TRUE}
source(file.path(getOption("fegloekBaseDir"), "R", "variables.R"), 
       encoding=getOption("encoding"))
source(file.path(getOption("fegloekBaseDir"), "R", "functions.R"), 
       encoding=getOption("encoding"))
```

Durch diese Befehlszeilen sollten (unter anderem) der data.frame 'LCT3lookuptable' sowie die Funktion 'extractDate()' für das Skript verfügbar sein.


## Einlesen der Daten

Ähnlich zu unserer Sitzung "Phänologie" wird heute eine Zeitreihe aus den Dateien erzeugt.
Dies geschieht für den Anfang und das Ende der Vegetationsperiode. Bitte beachten Sie dass die Daten schon in geografischen Koordinaten und nicht im UTM-Format vorliegen.
Zunächst lesen wir alle Dateien welche mit dem jeweiligen angegebenen Namensmustern im Verzeichnis data.dir gefunden werden. Dann werden diese mit dem Befehl 'stack()' zu einem 3-dimensionalen Raster zusammengefügt.

```{r, message=FALSE, warning=FALSE}
data.dir <- file.path(getOption("fegloekDataDir"), getOption("fegloekRegion"))
files1 <- list.files(data.dir, pattern="Increase.Num_Modes_01.tif$", full.names=TRUE)
stackVegStart <- stack(files1)
files2 <- list.files(data.dir, pattern="Minimum.Num_Modes_01.tif$", full.names=TRUE)
stackVegEnd <- stack(files2)
```

## Verarbeiten der Daten

Nun erzeugen wir für einige zuvor schon definierte Punkte aus diesem 3D-Raster Zeitreihen. Die Punkte sind für jede Region vorgegeben (schauen Sie sich das Ergebnis des Befehls getOption("fegloekPoints") in der Konsole an).

```{r, message=FALSE, warning=FALSE}
focus_points <- getOption("fegloekPoints")
print(focus_points)
```

Um die Daten extrahieren zu können wird mit SpatialPoints ein georeferenzierte Objekt aus dem data.frame focus_points erzeugt. Mit dem Befehl 'extract()' werden dann an diesen Punkten die Daten aus den Raster-Dateien entnommen und in den data.frames 'dfVegStart' und 'dfVegEnd' gespeichert.

```{r}
sPoints  <- SpatialPoints(focus_points,
                          proj4string=CRS("+proj=longlat +ellps=WGS84"))

dfVegStart <- extract(stackVegStart, sPoints, df=TRUE)
dfVegStart = dfVegStart[, -1]
dfVegEnd   <- extract(stackVegEnd, sPoints, df=TRUE)
dfVegEnd   = dfVegEnd[, -1]

# die Funktion extractDate befindet sich in der Datei R/functions.R !
vegDate    <- extractDate(colnames(dfVegStart))

# schauen wir uns den erzeugten Vektor an:
print(vegDate)


```

**Aufgabe:**

Setzen Sie nun ungültige Werte der data.frames dfVegStart und dfVegEnd auf NA (also ungültig bzw. nicht-existent). Den NA Wert (auch Füllwert genannt) finden Sie auf der MODIS homepage des Produkts MCD12Q2:
https://lpdaac.usgs.gov/dataset_discovery/modis/modis_products_table/mcd12q2. Speichern Sie den fill_value in der Variable veg_fill_value.
*Tipp:* Falls Sie vergessen haben wie Sie Werte eines data.frames oder vector ersetzen können schauen Sie im Handout der Sitzung Phänologie nach.

```{r, echo=FALSE, results="hide", message=FALSE, warning=FALSE}
vegInvalid <- 32767
dfVegStart[dfVegStart==vegInvalid] = NA
dfVegEnd[dfVegEnd==vegInvalid] = NA

# data.frame transponieren
dfVegStart_transp = as.data.frame(t(dfVegStart))
dfVegEnd_transp   = as.data.frame(t(dfVegEnd))

```

```{r, eval=FALSE}

#vegInvalid <- ???
#
#dfVegStart ???
#dfVegEnd   ???

# data.frame transponieren
dfVegStart_transp = as.data.frame(t(dfVegStart))
dfVegEnd_transp   = as.data.frame(t(dfVegEnd))
```

Um zu verstehen das der Befehl 't()' bewirkt vergleichen Sie auf der Konsole die Ausgabe für 'dfVegStart' und 'dfVegStart_transp'.
Nun berechnen wir aus dem Anfang und dem Ende die Dauer der Vegetationsperiode für jedes Jahr:

```{r}
dfGSL <- dfVegEnd_transp - dfVegStart_transp
dfGSL$date = vegDate
```

**Aufgabe:**
Verschmelzen den data.frame mit 'melt()' um ihn für die graphische Ausgabe mit ggplot vorzubereiten. Wir wollen dass alle Spalten mit Ausnahme der Spalte 'date' verschmolzen werden (die Ausnahme wird mit dem Argument 'id.vars="date"' angegeben).

```{r, echo=FALSE}
melted.dfGSL <- melt(dfGSL, id.vars="date")
```

```{r, eval=FALSE}
# melted.dfGSL <- ???
```

## Grafikausgabe

Nun öffnen wir eine PDF-Datei und plotten den Verlauf der Vegetationsperiode.

```{r}
p <- ggplot(melted.dfGSL, aes(x=date, y=value))
p <- p + geom_line()
p <- p + scale_x_date()
p <- p + xlab("Datum") + ylab("Vegetationsperiode [Tage]")
p <- p + facet_wrap(~variable, ncol=1)
```
```{r, eval=FALSE}
file_plot1 <- paste0(getOption("fegloekRegion"), "_GSL.pdf")
pdf(file.path(getOption("fegloekFigDir"), file_plot1), paper="special", width=8, height=8)
print(p)
dev.off()
```
```{r, warning=FALSE, message=FALSE, echo=FALSE, fig.width=8, fig.height=5}
print(p)
```

# Abhängigkeit der Vegetationsperiode von der Höhe

Die Gruppen BANGLADESH, BORNEO, MEXICO, NWBRAZIL, SAFRICA, SEBRAZIL und SWAUSTRALIA sollten
nun zu einer anderen Region wechseln, entweder NEAMERICA, NEASIA, NEUROPA, SEAUSTRALIA oder SEEUROPE.
Dafür muss die entsprechende Zeile aus obiger Initialisierung angepasst werden.

```{r}
fegloekOptions(region="SEEUROPE")
if (any(getOption("fegloekRegion") == c("BANGLADESH", "BORNEO", "MEXICO", "NWBRAZIL",
                   "SAFRICA", "SEBRAZIL", "SWAUSTRTALIA")))
  warning("Falsche Region!")
```

## Einlesen und Verarbeiten der Daten

Im Folgenden wird eine durchschnittliche Vegetationsperiode über die Jahre 2001 bis 2010
für einen bestimmten Auschnitt ("kElevExtent") in der Karte berechnet. rValid zählt,
wieviele gültige Werte rVegStart und rVegEnd haben. Wenn die Vegetationsperiode
null ist, setzen Sie auf NA.

```{r}
data.dir <- file.path(getOption("fegloekDataDir"), getOption("fegloekRegion"))
years <- c(2006:2010)
if (exists("rGSL")){
  rm(rGSL)
}

for (y in years) {
  print(y)
  # daten lesen 
  file1 <- file.path(data.dir, 
          paste0("MCD12Q2_", y, "-01-01.Onset_Greenness_Increase.Num_Modes_01.tif"))
  rVegStart <- raster(file1)
  rVegStart = crop(rVegStart, getOption("fegloekVegDynExtent"))
  rVegStart[rVegStart==32767] = NA
  
  file2 <- file.path(data.dir, 
          paste0("MCD12Q2_", y, "-01-01.Onset_Greenness_Minimum.Num_Modes_01.tif"))
  rVegEnd <- raster(file2)
  rVegEnd = crop(rVegEnd, getOption("fegloekVegDynExtent"))
  rVegEnd[rVegEnd==32767] = NA
  
  if (exists("rGSL")) {
    rNewGSL = rVegEnd - rVegStart
    rGSL[is.finite(rNewGSL)] = rGSL[is.finite(rNewGSL)] + rNewGSL[is.finite(rNewGSL)]
    rValid[is.finite(rNewGSL)] = rValid[is.finite(rNewGSL)] + 1
  } else {
    rGSL <- rVegEnd - rVegStart
    rValid <- rGSL
    rValid[is.finite(rGSL)] = 1
    rValid[!is.finite(rGSL)] = 0
  }
}
rGSL <- rGSL / rValid
rGSL[rGSL==0] = NA
```

Wir wandeln die Daten in einen data.frame um und benennen der Spalten neu.

```{r}
dfGSL <- as.data.frame(rasterToPoints(rGSL))
colnames(dfGSL) <- c("long", "lat", "GSL")
```

Nun laden wir die Landklassifikation. Damit die unterschiedlichen Datensätze verrenchent werden können muss evtl. die Auflösung angepasst werden. Dies erfolgt mit dem raster-Befehl 'resample'. Die methode 'ngb' gibt dabei an, dass wir die 'nearest neighbor' methode verwenden wollen. Im Anschluss vereinen wir die Datensätze.


```{r}
file3 <- file.path(data.dir, "MCD12Q1_GEO_hres_2010-01-01.Land_Cover_Type_3.tif")
rLCT <- raster(file3)
rLCT = crop(rLCT, getOption("fegloekVegDynExtent"))
rLCT = resample(rLCT, rGSL, method="ngb")
dfLCT <- as.data.frame(rasterToPoints(rLCT))
colnames(dfLCT) <- c("long", "lat", "id")
dfLCT = merge(dfLCT, LCT3lookuptable, by="id", all.x=TRUE)
```

Ein digitales Höhenmodel (GTOPO30) wird geladen.

```{r}
file4  <- file.path(data.dir, "GTOPO30.tif")
rGtopo <- raster(file4)
rGtopo = crop(rGtopo, getOption("fegloekVegDynExtent"))
rGtopo = resample(rGtopo, rGSL, method="ngb")
dfGtopo <- as.data.frame(rasterToPoints(rGtopo))
colnames(dfGtopo) <- c("long", "lat", "elevation")
```

Anschließend werden alle drei Datensätze anhand fer Koordinate-Spalten verschmolzen.

```{r}
dfData <- merge(dfGSL, dfGtopo, by=c("long", "lat"))
dfData = merge(dfData, dfLCT, by=c("long", "lat"))
```

Im letzten Schritt wird einen Scatterplot erzeugt, mit der Höhe über NN
als unabhängige Variable und der Vegetationsperiode als abhängige Variable.
Unterteilt wird es nochmals nach Landbedeckung.

## Grafikausgabe

```{r}
transparentColor <- rgb(1, 0.5, 0, 0.01, maxColorValue=1)
p <- ggplot(data=dfData, aes(x=elevation, y=GSL))
p = p + geom_point(color=transparentColor)
p = p + geom_smooth(se=TRUE, color='#2957FF')
p = p + xlab("Höhe über NN [m]")
p = p + ylab("Vegetationsperiode [Tage]")
p = p + facet_wrap(~name, ncol=3, scale="free_y")
```
```{r, eval=FALSE}
file_plot2 <- paste0(getOption("fegloekRegion"), "_GSL.png")
png(file.path(getOption("fegloekFigDir"), file_plot2), width=1024, height=800)
dev.off()
```
```{r, message=FALSE, warning=FALSE, echo=FALSE, fig.ext='png', dpi=150, fig.width=8, fig.height=8}
print(p)
```

# Hausaufgaben

1. Prüfen Sie die Position der 4 Fokuspunkte ihrer Region mit Google Maps. Interpretieren Sie mit dieser Zusatzinformation ihren Linienplot. Können Sie unterschiedliche Vegetationsperioden der 4 Punkte durch diese Zusatzinformation besser einordnen? Falls sie 'missing data' Werte in ihrer Abbildung haben: was könnte bei ihrer Region der Grund sein? **(2 Punkte)**

2. Wir haben heute unter anderem eine Interpolation zweier Raster-Datensätze durchgeführt (Befehl resample). Erläutern Sie warum wir dies durchführen mussten. Überlegen Sie ausserdem was die methodischen Unterschiede zwischen 'bilinear' und 'ngb' sind. Welche Methode würden Sie verwenden wenn Temperatur, NPP, oder NDVI Werte interpoliert werden sollen - welche Methode würden Sie für die Interpolation von Landnutzungsklassen verwenden? Begründen Sie Ihre Entscheidung. **(2 Punkte)**

3. Wir verwenden heute in Plot2 ein neues geom: *geom_smooth()*. Begründen Sie kurz warum Sie in PLot2 unterschiede in der 'Dicke' der Unsicherheitsbänder in den einzelnen Landnutzungs-Panelen sehen. Ausserdem: was bedeutet das Argument 'se=TRUE'? **(2 Punkte)**

4. Erzeugen Sie einen neuen Plot basierend auf Plot2 indem Sie allen Landbedeckungsklassen in einem Panel darstellen. Färben Sie die Daten der einzelnen Landnutzungsklassen unterschiedlich ein (Hinweis: kopieren Sie die Plotbefehle der Übung und passen sie relevante ggplot Befehle an; Tipp: u.a. facet_wrap, scale_color_manual) **(3 Punkte)**

5. Erzeugen Sie einen weitere Abbildung in der Sie eine andere sinnvolle Variable mit GSL in Beziehung setzen (Hinweis: die Daten existieren schon in unserem data.frame). **(2 Punkte)**

6. Vergleichen Sie die Ergebnisse von PLot2 für zwei verschiedenen Regionen (wiederholen Sie dazu das Skript mit einer Region der Vergleichszone: temperate - tropisch oder temperat - boreal). Beschreiben Sie die Ergebnisse und diskutieren Sie ihre Beobachtungen.**(3 Punkte)**  

7. In unserem heutigen Skript verwenden wir zwei unterschiedliche Ausgabe-Befehle (*pdf()*, *png()*). Betrachten Sie die Zeilen im Code und die jeweilige Hilfe-Seite. Beschreiben Sie die Unterschiede - wann wuerden Sie welches Kommando bevorzugen? **(2 Punkte)**

# Literatur
