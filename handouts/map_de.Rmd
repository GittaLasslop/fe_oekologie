---
title: "Fernerkundung globale Ökologie"
subtitle: "Paket Einführung"
author: "[Lasslop](mailto:gitta.lasslop@senckenberg.de)/[Werner](mailto:christian.werner@kit.edu)"
classoption: a4paper
#lang: de-DE
output:
  pdf_document:
 # tufte::tufte_handout:
  #  latex_engine: pdflatex
  #  fig_caption: yes
  #  includes:
  #   in_header: styles.tex
##    toc: true

---

# Überblick

In dieser Sitzung werden wir

1) zunächst weitere Pakete installieren,

2) Kartenabbildungen mit ggplot erstellen und diese anpassen,

3) eine Funktion zum Einlesen von Daten schreiben,

4) die Daten aufbereiten, und

4) die eingelesen Daten abbilden und zusätzlich vordefinierte Punkte in die Abbildung einzeichnen.

Versuchen Sie möglichst genau nachzuvollziehen was in diesem Skript passiert. Überprüfen Sie hierfür immer wieder was in den einzelnen Variablen abgespeichert und verändert wurde. Die Befehle `head()`,`summary()` und `str()` sind hierfür hilfreich. Die Hilfeseiten, die für einzelne Funktionen mit `?Funktionsname` aufgerufen werden können, beschreiben die Funktionen, deren Parameter und Rückgabewerte.


## Pakete laden und installieren

Zunächst müssen alle benötigten Pakete installiert werden. Dies sind in unserem Fall Pakete zum ...

1. Prozessieren von geokodierten Rasterdaten (raster, rgeos), 

2. Visualisieren (ggplot2; [Online Hilfe](http://docs.ggplot2.org/current/)),

3. Basiskarten (rworldmap, maps, mapproj)

Wir können nun die Pakete einzeln mit *install.packages* installieren und mit *library* laden. Da wir hier eine ganze Liste an Paketen haben benutzen wir eine Schleife:

```{r, eval=FALSE, message=FALSE}
for (p in c("raster", "rgeos", "ggplot2", "rworldmap", 
            "maps", "mapproj", "rgdal")) {
  if (!require(p, character.only=TRUE)) {
    install.packages(p)
  }
  library(p, character.only=TRUE)
}
```
*!require()* gibt hierbei FALSE zurück wenn das Paket bereits installiert ist, mit dem keyword character.only wird übermittelt, dass der Paketname als *character* Datentyp übergeben wird. (So wie auch beim Aufruf von library.) 

## Verzeichnisse
Wir wechseln nun in unser Arbeitsverzeichnis und setzen die Verzeichnisse in denen wir die Daten und Abbildungen speichern wollen.

Das Kommando `getwd()` in der Konsole zeigt Ihnen R Ihr aktuelles Verzeinis an. 

```{r message=FALSE, warning=FALSE, results='hide'}
setwd('/home/gitta/R/Lehre/FE_OEKOLOGIE/fe_oekologie_2020/handouts/')
data.dir='data/map_de/ALASKA/'
plot.dir='plots/map_de/'
```

```{r, echo=FALSE}
source(file.path("R", "variables.R"), encoding=getOption("encoding"))
source(file.path( "R", "functions.R"), encoding=getOption("encoding"))
```

# Karten mit ggplot (grammar of graphics)

In R gibt es verschiedene Systeme um Grafiken zu erstellen. Das Paket ggplot2 ist sehr vielseitig und bietet einen sehr systematischen Umgang mit Abbildungen. 

## Weltkarte

Da wir nicht die ersten sind die R benutzen um Karten
zu erstellen nutzen wir eine vorgefertigte Karte aus dem Paket "maps",
die für die Darstellung mit dem Befehl `map_data` aus dem Paket `ggplot2` in einen data.frame umgewandelt wird.
Die Erstellung einer Grafik mit ggplot beginnt stehts mit dem Aufruf der Funktion `ggplot()`. An dieser Stelle wird festgelegt welche Daten verwendet werden und welche Variablen der x- und y-Achse zugeordnet werden sollen. 
Da in diesem Fall die Ländergrenzen mit abgebildet werden muss noch angegeben werden welche Punkte zu einem Land gehören. Diese Information ist in der Variablen "group" hinterlegt.

Hier sind die Befehle aus dem Paket ggplot2 Paket, mit denen eine erste Weltkarte in Form der Ländergrenzen erstellt wird. Führen sie nach jeder Zeile den Befehl print(p) aus, um zu sehen, welche Auswirkungen die jeweiligen Änderungen haben.

```{r, message=FALSE, warning=FALSE, out.width="75%", fig.align='center'}
library(ggplot2)
worldmap <- map_data("world")
p <- ggplot(data=worldmap, aes(y=lat, x=long, group=group))
p = p + geom_path()
p = p + coord_fixed()
p = p + labs(title="Laendergrenzen")
p = p + xlab("Laenge")
p = p + ylab("Breite")
print(p)
```
-------------------------------------
**Aufgabe**
Die Zeile 
$p = p + coord \_ fixed()$ 
kann z.B. mit
$p = p + coord \_ map("ortho", orientation=c(45, 8, 0))$
ersetzt werden.
Finden Sie mit Hilfe der Hilfeseiten heraus, ob es noch andere Projektionen gibt und probieren diese aus.
-------------------------------------

## Regionale Karte mit Landbedeckung
Als nächstes wollen wir die erste Abbildung mit Fernerkundungsdaten erstellen. Wir benutzen hierfür das MODIS-Produkt der Landbedeckungsklassen.

Die Daten für die heutige Stunde finden sie unter:

https://swift.dkrz.de/v1/dkrz_a5a4d477-007a-4a5f-8c5e-16156bbc5646/FE/map_de.zip?temp_url_sig=8d434103ca8df43abc710af739a6fb52560c6f80&temp_url_expires=2020-07-27T15:54:58Z

Die von uns vorprozessierten Daten (LUC_ALASKA.zip) werden geladen. Sie können die Daten entweder mit der Funktion download.file() oder von Hand herunterladen. Achten Sie darauf die Datei im Data Verzeichnis abzuspeichern.

Lesen Sie nun die Landbedeckungsdaten Klasse 3 für das Jahr 2001 ein. Die Rasterdaten
werden in einen "data.frame" umgewandelt und die Spalten umbenannt. Zunächst setzen wir den Dateinamen zusammen. Wir haben unterschiedliche Dateien für unterschiedliche Jahre und land cover typ Klassifizierungen, daher wollen wir den Dateinamen flexibel zusammensetzen:

```{r}
year <- 2001
lct <- 3
file <- file.path(data.dir, 
                  paste0("MCD12Q1_GEO_lres_", year, 
                         "-01-01.Land_Cover_Type_", lct, ".tif"))
```

------------------------------------------------------------------
**Aufgabe**
Das nun folgende Einlesen von tif-Dateien wird in fast allen folgenden Skripten wieder kommen.
Deshalb werden wir eine Funktion für diesen Teil erstellen, die in einer 
Datei 'functions.R' gespeichert werden soll. 
Dabei wird dieser Funktion der Pfad zu dem GeoTiff als Argument übergeben. 
Die Daten werden gelesen und in einen `data.frame` umgewandelt.
Die Funktion liefert dann die Datentabelle (data.frame) zurück, 
welche einer Variablen zugewiesen werden kann. Der Funktionsname 
soll `geotiff2df` sein. Wir werden die Funktion in den folgenden 
Stunden immer wieder erweitern.
-------------------------------

```{r}
library(raster)
rLCT  <- raster(file)
dfLCT <- as.data.frame(rasterToPoints(rLCT))
colnames(dfLCT) <- c("x", "y", "id")
```
Das r im Variablennamen rLCT soll uns hier an den Datentyp erinnern.
Zu Erinnerung:
Funktionen in R haben die allgemeine Form:
```{r,eval=FALSE}
Funktionsname <- function(InputPar1,InputPar2,...){
  R code
  return(value)
}
```


-------------------------------------
**Aufgabe**
 Entfernen Sie den Wert für 'FillValue/Unclassified' in der Spalte 'id' des data.frames 'dfLCT',
 so dass er nicht in der Legende auftaucht. Den Zahlenwert für 'FillValue/Unclassified' 
 finden Sie auf der MODIS-Webseite: 
 \href{https://ladsweb.modaps.eosdis.nasa.gov/filespec/MODIS/6/MCD12Q1}{\textcolor{blue}{MODIS-Webseite (https://ladsweb.modaps.eosdis.nasa.gov/filespec/MODIS/6/MCD12Q1)}}.
-------------------------------------


```{r, echo=FALSE}
dfLCT = subset(dfLCT, id < 254)
```

Allen gültigen numerischen IDs sollen nun ihre Namen zugewiesen. Dafür muss eine lookup-Tabelle LCT3lookuptable erzeugt werden, die die Spalten 'id' und 'name' hat. 

--------------------------------------------------------------
**Aufgabe**
Suchen Sie auf der 
\href{https://ladsweb.modaps.eosdis.nasa.gov/filespec/MODIS/6/MCD12Q1}{\textcolor{blue}{MODIS-Webseite (https://ladsweb.modaps.eosdis.nasa.gov/filespec/MODIS/6/MCD12Q1)}} 
nach der entsprechenden Tabelle (Land_Cover_Type_3 ) und erzeugen Sie einen data.frame mit zwei Spalten: 
1. der Klassennummer (class number) und 
2. dem Namen der Landbedeckungsklasse. 
Die erste Spalte soll den Namen "id"" erhalten, die zweite Spalte den Namen "name".
-------------------------------------

Die lookup-Tabelle und der Landnutzungsdatendatz werden im Folgenden anhand der gemeinsamen Spalte 'id' verbunden, 'all.X=TRUE' stellt hierbei sicher, dass alle Zeilen aus dfLCT erhalten bleiben, auch die, für die evtl. in LCTlookuptable kein Wert vorhanden ist. Ist ein 'id'-Wert aus dfLCT nicht in LCTlookuptable, bekommt 'name' den Wert 'NA' für 'not available'.

```{r}
dfLCT = merge(dfLCT, LCT3lookuptable, by="id", all.x=TRUE)
```

Nun können wir mit den Funktionen aus dem Paket ggplot2 wieder eine Karte erzeugen. Hierbei stehen die Landcover Klassifikationen im Vordergrund. Zusätzlich werden noch vier von uns vordefinierte Punkte (Variable 'points', V1-4) auf der Karte verzeichnet. An diesen werden in den folgenden Skripten Vegetationsindizes untersucht.

```{r, message=FALSE, warning=FALSE}
points <- data.frame(long = c(-143.54, -152.6, -147.12, -155), lat = c(61.43, 
64.85, 65.13, 67))

p <- ggplot(dfLCT, aes(x = x, y = y))
p = p + geom_raster(aes(fill = name))
p = p + geom_path(data = worldmap, size = 0.1, colour = "black",
                  aes(x = long, y = lat, group = group))
p = p + geom_point(data = points, aes(x = long, y = lat),
                   color = "black", shape = 10, size = 2.5)
p = p + geom_text(data = points, aes(x = long, y = lat, label =
                  paste0("V", rownames(points))),
                  hjust = c(-0.1, -0.1, 1.1, 1.1))
p = p + coord_fixed(xlim = c(min(dfLCT$x), max(dfLCT$x)),
                    ylim = c(min(dfLCT$y), max(dfLCT$y)), expand = FALSE)
p = p + theme(legend.position = "bottom")
p = p + guides(fill = guide_legend(title = NULL, ncol = 3))
p = p + labs(title = "MODIS MCD12Q1 Landcover")
p = p + xlab("Longitude")
p = p + ylab("Latitude")
p
```

-----------------------------------------------------------------
**Aufgabe**
Ändern Sie in den abgebildeten Kartenausschnitt so dass nur der Bereich zwischen 
Longitude -160 und -140 gezeigt wird. Setzen Sie die Legende statt unter die Abbildung 
über die Abbildung.  
Setzen Sie als Überschrift über die Legende den Text 'Land cover types'. 
Ändern Sie die Dicke der Ländergrenzen.
Sie müssen dafür lediglich den oben stehenden code abändern. Probieren Sie einfach Parameteränderungen aus
oder rufen Sie die Hilfeseiten für die einzelnen Befehle auf, oder googlen Sie.
-------------------------------------

Anschließend wird eine Karte mit der entsprechenden Region erzeugt und in einer PDF Datei gespeichert.


```{r, eval=FALSE}
file <- paste0("ALASKA_LCT", lct, "_", year, ".pdf")
pdf(file.path(plot.dir, file), paper="special", width=10, height=10)
print(p)
dev.off()
```

Die Abbildung gibt bereits eine gute Übersicht über die Verteilung der Landbedeckungsklassen. 
Der Befehl 'table()' zählt gleiche Werte in einem Vektor (eine Spalte eines data.frames ist ein Vektor) und bietet daher eine einfache zusätzliche Möglichkeit um die Verteilung von Klassen in einer Region zu quantifizieren.

```{r, eval=FALSE}
table(dfLCT$name)
```

# Hausaufgaben
1. Was setzt der Parameter ncol in der Funktion guide\_legend? **(1 Punkt)**

2. Wiederholen Sie das Daten einlesen, aufbereiten und plotten mit Land Cover Type 1. Das sollte idealerweise in Form einer for-Schleife mit der Variablen lct gemacht werden. **(2 Punkte)**

3. Es sind Daten für die Jahre 2001 und 2010 vorhanden. Schreiben Sie erneut eine Schleife für diese 2 Jahre, so dass Sie am Ende vier Karten haben: 2001 + LCT1, 2001 + LCT3, 2010 + LCT1, 2010 + LCT3. **(2 Punkte)**

4. Schreiben Sie eine Funktion, die eine Spalte 'name' mit der Landbedeckung als Character an den data.frame dfLCT anhängt (basierend auf der numerischen Spalte 'id' der Landbedeckungsklasse). **(1 Punkt)**

5. Benutzten Sie den Befehl 'scale_fill_manual' um den Biomen sinnvolle Farben zuzuweisen. (Mit der geladenen ggplot2 library können Sie mit ?scale_fill_manual die Hilfe aufrufen. Beachten Sie auch das cheat-sheet im OLAT.) **(1 Punkt)**
